# Rabbit MQ

## 主要的角色
1. Producer: 投递消息的一方，创建消息发布到MQ，消息主要分为消息体(`payload`)和标签(`label`)
    - 标签主要是存储`路由键`和`交换机`
    - 消息体主要是序列化之后的内容，可能格式是字符串或者二进制的信息
2. Customer: 接收消息的一方，并订阅到队列上，消费消息是指的消费消息体，在消费路由的过程中标签会被丢弃，存入队列的只有消息体
    - 所以消息者不知道谁生产的消息，也不需要知道
3. Broker: 消息中间件的服务节点
    - 生产者将消息包装后，发送到Broker(AMQP协议对应了basic.publish)
    - 消费者订阅并接收消息，将消息反序列化然后处理消息(AMQP洗衣对应了basic.consume和basic.get)
4. Queue: 是rabbitMQ的内部对象，用于存储消息(kafka将消息存储在topic上)
    - 多个消费者订阅同一个生产者的消息，只有一个消费者可以消费这个消息，也就是说默认队列不支持广播
5. Exchange: 生产者的消息会被交换机发送到能够匹配上的队列，路由不到则返回给生产者或者直接丢弃
6. RoutingKey: 路由键，生产者将消息发送给消费者都会附带一个RoutingKey,通过它判断消息会被派发到哪个具体的队列上
7. Binding: 生产者将消息发送到交换机，由交换机决定消息被派发到绑定到该交换机的队列上
    - 在绑定消息的时候使用的是BindingKey
    - 在发送消息的时候使用的是RoutingKey
    - 在direct类型的交换机中是直接两个相等，但是topic类型的交换机可以不相等
8. Connection: 无论是生产者还是消费者都需要向Broker建立TCP连接(即为Connection)
9. Channel: 创立Connection后接着可以创建信道，每个信道都会被指派一个唯一的id,信道是建立在Connection之上的连接，RabbitMQ处理每条AMQP指令都是通过信道完成的

### Exchange
1. fanout: 它会将所有的发送到该交换机的消息路由到所有与该交换机绑定的交换机队列上
2. direct: 它会将发送的消息派发到BindingKey和RoutingKey相同的
3. topic: 拥有通配符匹配的交换机

## 运行流程
### 生产者
1. 生产者链接到RabbitMQ Broker上，建立一个连接，开启一个信道(Channel)
2. 生产者声明一个交换机，并设置相关属性，比如交换机类型、是否持久化、是否自动删除等
3. 生产者声明一个队列，并设置相关属性，是否排他、持久化、自动删除等
4. 生产者通过路由键将交换机和队列绑定到一起
5. 生产者发送消息到RabbitMMQ Broker上，其中包含路由键、交换机等信息
6. 交换机根据收到的信息查找对应的队列
    - 如果找到则将生产者的消息存入到对应的队列中
    - 如果没有找到则根据生产者配置的属性决定丢弃还是退还给生产者
7. 关闭信道
8. 关闭连接

### 消费者
1. 消费者链接到RabbitMQ Broker上，建立一个连接，开启一个信道(Channel)
2. 消费者向RabbitMQ Broker请求消费对应队列的消息，可能设置相应的回调函数，以及一些准备工作
3. 等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接受消息
4. 消费者确认(ack)接收到消息
5. RabbitMQ从队列删除相应已经被确认的消息
6. 关闭信道
7. 关闭连接

